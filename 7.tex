\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[T2A]{fontenc}
\usepackage{titlesec}
%\usepackage{verbatim}
\usepackage[left=25mm, right=15mm, top=20mm, bottom=20mm, footskip=10mm]{geometry}
\usepackage{amsmath}
\usepackage{epigraph}
\usepackage{tikz}
\usepackage{latexsym}
%\usepackage{listings}
\frenchspacing 
\newcommand{\path}{\rightsquigarrow}
\titleformat{\section}[hang]{\normalsize\bfseries}{\thesection~}{0pt}{}
\titlespacing{\section}{\parindent}{\baselineskip}{\baselineskip}

\titleformat{\subsection}[hang]{\normalsize}{\thesubsection~}{0pt}{}
\titlespacing{\subsection}{\parindent}{0pt}{0pt}
\parindent=1.25cm 

\title{Тема 7. Эйлеровы графы }
\date{}

\begin{document}

\maketitle

\epigraph{Автор конспекта: Родион Лыков}


\section{Определения}
\begin{itemize}
\item \textbf{Эйлеров цикл} это такой цикл в графе, который проходит по каждому ребру ровно один раз.
\item \textbf{Эйлеров путь} это такой путь в графе, который проходит по каждому ребру ровно один раз.
\item Граф называют \textbf{Эйлеровым}, если в нем есть Эйлеров цикл.
\item Граф называют \textbf{Полуэйлеровым}, если в нем есть Эйлеров путь.
\item Необходимое и достаточное условие существования \textbf{Эйлерового цикла}: если в неориентированном графе степени всех вершин четные и есть не более одной компоненты связности с ребрами, то в графе есть Эйлеров цикл.
\item Необходимое и достаточное условие существования \textbf{Эйлерового пути}: если в неориентированном графе не более двух вершин с нечетной степенью и есть не более одной компоненты связности с ребрами, то в графе есть Эйлеров путь.

\end{itemize}

\section{Поиск Эйлерова пути и цикла}
Алгоритм $dfs$ находит нам Эйлеров путь, но если в графе есть цикл, то он нам найдет именно его. Однако, чтобы алгоритм смог найти путь (когда цикла нет), он должен запуститься из вершины с нечетной степенью. Также мы заведем массив $cnt$, который показывает, сколько ребер из вершины $x$ мы удалили (чтобы не рассматривать лишний раз уже удаленные ребра). Сама структура графа выглядит вот так:

\begin{verbatim}
    struct Edge{
        int y;          // куда идет ребро
        bool del;       // удалено ли оно
        Edge* rev;      // ссылка на обратное ребро 
    };
    vector<vector<Edge*>>e;
    void add_edge(int x, int y) {
        Edge* v = new Edge{y, 0, 0};
        Edge* v2 = new Edge{x, 0, v};
        v->rev = v2;
        e[x].push_back(v);
        e[y].push_back(v2);
    }
\end{verbatim}

Чтобы найти нужную вершину просто проверим степени вершин перед запуском Эйлерова пути:
\begin{verbatim}
    vector<int>deg(n+1);
    for(int i = 1; i <= n; i++) {
        for(auto& y : e[i]) {
            deg[i]++;
            deg[y->y]++; // Это указатель, поэтому обращение y->y
        }
    }
    int S = 1;
    int q = 0;
    for(int i = 1; i <= n; i++) {
        deg[i] /= 2; // степень мы посчитали в два раза больше, поэтому поделим
        if(deg[i] % 2 == 1) {
            S = i;      // устанавливаем возможный старт
            q++;        // увеличиваем счетчик
        }
    }
    if(q > 2) {
        cout << "В графе нельзя найти Эйлеров путь";
    }
    dfs(S);
\end{verbatim}

Сам $dfs$ выглядит вот так:
\begin{verbatim}
    void dfs(int x) {
        while(cnt[x] < e[x].size()) {
            auto& y = e[x][cnt[x]];
            cnt[x]++; // увеличиваем счетчи, чтобы не рассматривать ребро еще раз
            if(y->del) continue;
            y->del = 1;
            y->rev->del = 1; // удаляем ребра
            dfs(y->y);
        }
        ans.push_back(x);
    }
\end{verbatim}


\section{Где прячется Эйлеров путь}

Ребро в графе можно между вершинами $a$ и $b$ можно воспринимать как <<после $a$ можно поставить $b$>>. Тогда если мы найдем в таком графе Эйлеров путь, то мы узнаем, как можно расположить элементы так, чтобы соблюдались условия на соседние элементы. Например, пусть у нас есть такая задача: нам дано $n$ доминошек, на обоих концах написаны два целых числа, не обязательно разных. Две соседние доминошки можно поставить вместе, если на концах, которые мы присоединим, совпадут числа, доминошки можно крутить. Например, если нам даны две доминошки $(10, 5), (3,3), (3,5)$, то мы сможем поставить их вместе в таком виде: $(10,5), (5,3), (3,3)$. Заметьте, здесь как раз нам ставят условие, что мы можем после одного элемента поставить другой, или говоря по-другому у нас есть условие, можно ли два элемента расположить рядом. Тогда мы заведем такой граф: в доминошке $(x,y)$ мы проведем ребро из $x$ в $y$. Тогда, если мы найдем Эйлеров путь на этом графе мы получим ответ. Например, в описанном выше примере мы найдем ответ $10 5 3 3$, и из него можно легко восстановить сами доминошки: $(10,5), (5,3), (3,3)$.

\section{Решение задачи <<Платиновая звезда>>}
В этой задаче вам нужно построить массив, чтобы все соседние произведения были различны. Также вам нужно минимизировать количество различных чисел. 

Чтобы решить задачу, вам нужно сразу же понять простой факт: надо упростить условие о различных произведениях. Смотрите, если вы поставите числа $5 20$ рядом, то вы больше не сможете ставить рядом $10 10$, $4 25$ и так далее, потому что они все дают произведение $100$. Давайте будем использовать только простые числа в массиве, с простыми числами мы сразу знаем, что произведения совпадут только если мы поставим одни и те же простые числа вместе. Теперь у нас появилась зависимость: можно ли поставить число $q$ после числа $p$ и она задается в виде ребра $(p,q)$ в графе. Но тогда нам нужно просто обойти все ребра в этом графе, чтобы поставить простые числа. Если мы уже прошли по ребру $(p,q)$, то больше по нему мы ходить не можем --- получим то же произведение. 

Тогда, чтобы решить задачу просто постройте полный граф по простым числам и обойдите его Эйлеровым путем. Перебрать количество используемых простых чисел можно просто в цикле: фиксируете его и смотрите по формуле.

\section{Решение задачи <<Kotlin>>}
Просто сведите задачу к определению <<можно ли после какого-то элемента поставить другой элемент>>. Например, после <<ko>> можно поставить <<t>>, <<tl>>, <<tlinkotlin>> и другие. Заметили? Все слова будут начинаться на букву <<t>>. Поэтому в графе добавим ребро между буквами <<k>> и <<t>>. У вас получится граф на $6$ вершинах, где осталось найти Эйлеров путь. Заметьте, что граф ориентированный.
    
\end{document}
